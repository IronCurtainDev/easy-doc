<?php

namespace EasyDoc\Domain\FileGenerators\SDK;

use EasyDoc\Docs\APICall;
use EasyDoc\Docs\SchemaBuilder;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;

/**
 * Generate TypeScript API client SDK.
 */
class TypeScriptSDKGenerator
{
    protected string $baseUrl;
    protected string $className = 'ApiClient';
    protected Collection $endpoints;

    public function __construct()
    {
        $config = config('easy-doc', []);
        $this->baseUrl = config('app.url', 'http://localhost') . ($config['base_path'] ?? '/api/v1');
        $this->endpoints = collect();
    }

    /**
     * Set the class name for the generated SDK.
     */
    public function setClassName(string $name): static
    {
        $this->className = $name;
        return $this;
    }

    /**
     * Set base URL.
     */
    public function setBaseUrl(string $url): static
    {
        $this->baseUrl = $url;
        return $this;
    }

    /**
     * Add an endpoint.
     */
    public function addEndpoint(APICall $endpoint): static
    {
        $this->endpoints->push($endpoint);
        return $this;
    }

    /**
     * Generate the TypeScript SDK.
     */
    public function generate(): string
    {
        $ts = $this->generateHeader();
        $ts .= $this->generateInterfaces();
        $ts .= $this->generateClientClass();

        return $ts;
    }

    /**
     * Generate file header with imports.
     */
    protected function generateHeader(): string
    {
        $ts = "/**\n";
        $ts .= " * Auto-generated API Client SDK\n";
        $ts .= " * Generated by EasyDoc\n";
        $ts .= " * @see https://github.com/iron-curtain/easy-doc\n";
        $ts .= " */\n\n";

        return $ts;
    }

    /**
     * Generate TypeScript interfaces from schemas.
     */
    protected function generateInterfaces(): string
    {
        $ts = "// ============ Interfaces ============\n\n";

        $schemas = SchemaBuilder::all();

        foreach ($schemas as $name => $schema) {
            // Skip response wrappers for cleaner output
            if (str_ends_with($name, 'Response') || str_ends_with($name, 'CollectionResponse') || str_ends_with($name, 'PaginatedResponse')) {
                continue;
            }

            $ts .= $this->generateInterface($name, $schema);
        }

        // Add common response types
        $ts .= $this->generateApiResponseTypes();

        return $ts;
    }

    /**
     * Generate a single interface.
     */
    protected function generateInterface(string $name, array $schema): string
    {
        $ts = "export interface {$name} {\n";

        $properties = $schema['properties'] ?? [];
        $required = $schema['required'] ?? [];

        foreach ($properties as $propName => $propDef) {
            $type = $this->schemaToTypeScript($propDef);
            $optional = !in_array($propName, $required) ? '?' : '';
            $description = $propDef['description'] ?? null;

            if ($description) {
                $ts .= "  /** {$description} */\n";
            }
            $ts .= "  {$propName}{$optional}: {$type};\n";
        }

        $ts .= "}\n\n";

        return $ts;
    }

    /**
     * Generate API response type wrappers.
     */
    protected function generateApiResponseTypes(): string
    {
        $ts = "// API Response wrapper\n";
        $ts .= "export interface ApiResponse<T> {\n";
        $ts .= "  success: boolean;\n";
        $ts .= "  message?: string;\n";
        $ts .= "  data: T;\n";
        $ts .= "}\n\n";

        $ts .= "export interface ApiError {\n";
        $ts .= "  success: false;\n";
        $ts .= "  message: string;\n";
        $ts .= "  errors?: Record<string, string[]>;\n";
        $ts .= "}\n\n";

        $ts .= "export interface PaginatedResponse<T> extends ApiResponse<T[]> {\n";
        $ts .= "  meta: {\n";
        $ts .= "    current_page: number;\n";
        $ts .= "    from: number;\n";
        $ts .= "    last_page: number;\n";
        $ts .= "    per_page: number;\n";
        $ts .= "    to: number;\n";
        $ts .= "    total: number;\n";
        $ts .= "  };\n";
        $ts .= "  links: {\n";
        $ts .= "    first: string;\n";
        $ts .= "    last: string;\n";
        $ts .= "    prev: string | null;\n";
        $ts .= "    next: string | null;\n";
        $ts .= "  };\n";
        $ts .= "}\n\n";

        return $ts;
    }

    /**
     * Generate the API client class.
     */
    protected function generateClientClass(): string
    {
        $ts = "// ============ API Client ============\n\n";

        $ts .= "export interface {$this->className}Config {\n";
        $ts .= "  baseUrl?: string;\n";
        $ts .= "  headers?: Record<string, string>;\n";
        $ts .= "  onError?: (error: ApiError) => void;\n";
        $ts .= "}\n\n";

        $ts .= "export class {$this->className} {\n";
        $ts .= "  private baseUrl: string;\n";
        $ts .= "  private headers: Record<string, string>;\n";
        $ts .= "  private onError?: (error: ApiError) => void;\n\n";

        // Constructor
        $ts .= "  constructor(config: {$this->className}Config = {}) {\n";
        $ts .= "    this.baseUrl = config.baseUrl || '{$this->baseUrl}';\n";
        $ts .= "    this.headers = {\n";
        $ts .= "      'Content-Type': 'application/json',\n";
        $ts .= "      'Accept': 'application/json',\n";
        $ts .= "      ...config.headers,\n";
        $ts .= "    };\n";
        $ts .= "    this.onError = config.onError;\n";
        $ts .= "  }\n\n";

        // Set token method
        $ts .= "  setToken(token: string): void {\n";
        $ts .= "    this.headers['Authorization'] = `Bearer \${token}`;\n";
        $ts .= "  }\n\n";

        // Base request method
        $ts .= "  private async request<T>(method: string, path: string, body?: any): Promise<T> {\n";
        $ts .= "    const response = await fetch(`\${this.baseUrl}\${path}`, {\n";
        $ts .= "      method,\n";
        $ts .= "      headers: this.headers,\n";
        $ts .= "      body: body ? JSON.stringify(body) : undefined,\n";
        $ts .= "    });\n\n";
        $ts .= "    const data = await response.json();\n\n";
        $ts .= "    if (!response.ok && this.onError) {\n";
        $ts .= "      this.onError(data);\n";
        $ts .= "    }\n\n";
        $ts .= "    return data;\n";
        $ts .= "  }\n\n";

        // Generate methods for each endpoint
        $grouped = $this->endpoints->groupBy(fn($e) => $e->getGroup() ?? 'General');

        foreach ($grouped as $group => $endpoints) {
            $ts .= "  // === {$group} ===\n\n";

            foreach ($endpoints as $endpoint) {
                $ts .= $this->generateMethod($endpoint);
            }
        }

        $ts .= "}\n\n";

        // Export default instance
        $ts .= "// Default instance\n";
        $ts .= "export const api = new {$this->className}();\n";

        return $ts;
    }

    /**
     * Generate a method for an endpoint.
     */
    protected function generateMethod(APICall $endpoint): string
    {
        $name = Str::camel($endpoint->getName());
        $method = strtoupper($endpoint->getMethod());
        $route = $endpoint->getRoute();
        $description = $endpoint->getDescription();
        $params = $endpoint->getParams();

        // Build parameters
        $paramList = [];
        $hasBody = in_array($method, ['POST', 'PUT', 'PATCH']);

        foreach ($params as $param) {
            $paramName = Str::camel($param->getName());
            $paramType = $this->phpTypeToTypeScript($param->getDataType());
            $optional = !$param->getRequired() ? '?' : '';
            $paramList[] = "{$paramName}{$optional}: {$paramType}";
        }

        // Generate JSDoc
        $ts = "  /**\n";
        if ($description) {
            $ts .= "   * {$description}\n";
        }
        foreach ($params as $param) {
            $paramName = Str::camel($param->getName());
            $desc = $param->getDescription() ?? '';
            $ts .= "   * @param {$paramName} {$desc}\n";
        }
        $ts .= "   */\n";

        // Method signature
        $paramsStr = implode(', ', $paramList);
        if ($hasBody && !empty($paramList)) {
            $ts .= "  async {$name}(data: { {$paramsStr} }): Promise<ApiResponse<any>> {\n";
            $ts .= "    return this.request('{$method}', '{$route}', data);\n";
        } elseif (!empty($paramList)) {
            $ts .= "  async {$name}({$paramsStr}): Promise<ApiResponse<any>> {\n";
            $ts .= "    return this.request('{$method}', '{$route}');\n";
        } else {
            $ts .= "  async {$name}(): Promise<ApiResponse<any>> {\n";
            $ts .= "    return this.request('{$method}', '{$route}');\n";
        }

        $ts .= "  }\n\n";

        return $ts;
    }

    /**
     * Convert OpenAPI schema to TypeScript type.
     */
    protected function schemaToTypeScript(array $schema): string
    {
        if (isset($schema['$ref'])) {
            $ref = str_replace(['#/definitions/', '#/components/schemas/'], '', $schema['$ref']);
            return $ref;
        }

        $type = $schema['type'] ?? 'any';

        return match ($type) {
            'integer', 'number' => 'number',
            'boolean' => 'boolean',
            'array' => isset($schema['items']) ? $this->schemaToTypeScript($schema['items']) . '[]' : 'any[]',
            'object' => 'Record<string, any>',
            default => 'string',
        };
    }

    /**
     * Convert PHP type to TypeScript.
     */
    protected function phpTypeToTypeScript(string $type): string
    {
        return match (strtolower($type)) {
            'integer', 'int', 'float', 'double', 'number' => 'number',
            'boolean', 'bool' => 'boolean',
            'array' => 'any[]',
            'object' => 'Record<string, any>',
            default => 'string',
        };
    }

    /**
     * Save SDK to file.
     */
    public function save(string $path): bool
    {
        $content = $this->generate();
        return file_put_contents($path, $content) !== false;
    }
}
